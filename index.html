<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>価値観当てゲーム - 1台で遊べる協力ゲーム</title>
    <meta name="description" content="1台のスマホでみんなで遊べる協力数字ゲーム「価値観当てゲーム」のWebアプリ版。">

    <!-- PWA -->
    <meta name="theme-color" content="#34675C">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" href="favicon.svg" type="image/svg+xml">

    <!-- iOS support -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="価値観当てゲーム">
    <link rel="apple-touch-icon" href="apple-touch-icon.png">

    <!-- SortableJS Library & Swap Plugin -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/plugins/Swap/Swap.min.js"></script>
    <style>
        :root {
            /* --- デザインシステム：ベースカラー --- */
            --bg-color: #f6f8fb;        /* アプリ全体の背景色：目に優しい薄いグレー */
            --card-bg: #ffffff;         /* カードの背景色：清潔感のある白 */
            --accent-color: #e9edf5;    /* 補助的なアクセント：区切り線や入力欄の背景 */

            /* --- メイン・アクションカラー --- */
            --primary-color: #7ccf6a;   /* プライマリー：肯定的なアクション（開始、決定） */
            --primary-hover: #63b955;   /* ホバー時の色 */

            /* --- サブカラー --- */
            --secondary-color: #4a7dff; /* セカンダリー：補助的なアクション（戻る、調整） */

            /* --- テキストカラー --- */
            --text-color: #1f2933;      /* 標準テキスト：高いコントラストの濃いグレー */
            --text-muted: #8a94a6;      /* 補助テキスト：控えめなグレー */

            /* --- 状態表示 --- */
            --success-color: #2ecc71;   /* 成功・クリア時の色 */
            --error-color: #ff4d4f;     /* 失敗・エラー時の色 */

            /* --- UI構成要素 --- */
            --radius: 18px;             /* 角丸の基準値：モダンで親しみやすい印象 */
            --shadow: 0 12px 30px rgba(0, 0, 0, 0.08); /* 浮遊感を出すシャドウ */

            /* --- タイポグラフィ --- */
            --font-main: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; /* iOS/Android/PCに最適化 */
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            overscroll-behavior-y: auto; /* Allow pull-to-refresh unless specifically problematic */
            overflow-x: hidden;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-main);
            overflow-x: hidden;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            width: 100%;
            height: 100dvh; /* Use dynamic viewport height */
            user-select: none;
            -webkit-user-select: none;
            margin: 0;
            padding: 0;
            position: relative;
        }

        #app {
            width: 100%;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            /* Precise safe area support */
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
            box-sizing: border-box;
            overflow: hidden;
        }

        .screen {
            display: none;
            width: 100%;
            height: 100%;
            flex-direction: column;
            animation: slideIn 0.3s ease-out;
            box-sizing: border-box;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            position: relative; /* 子要素の絶対配置用 */
        }

        .screen.active {
            display: flex;
            /* 垂直中央配置の徹底 */
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* Titles & Text */
        h1.title-large {
            font-size: 5rem;
            font-weight: 900;
            letter-spacing: -2px;
            background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-align: center;
            margin-bottom: 40px;
        }

        h2.screen-title {
            text-align: center;
            margin-top: 20px;
            margin-bottom: 24px;
            font-size: 1.5rem;
            color: var(--text-muted);
        }

        /* Distribution screen special layout for consistency */
        .dist-screen.active, .scrollable-screen.active {
            justify-content: flex-start !important;
            padding-top: 40px;
        }

        /* Fixed Layout for Screens like Player Settings */
        .screen.fixed-layout.active {
            justify-content: flex-start !important;
            padding: 0 !important; /* Reset padding to let header/content handle it */
            overflow: hidden; /* Disable whole-screen scroll */
        }

        .screen.fixed-layout .screen-header {
            flex-shrink: 0;
            width: 100%;
            padding: 20px 20px 0 20px;
            background: var(--bg-color);
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .screen.fixed-layout .screen-content {
            flex: 1;
            width: 100%;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: 10px 20px;
        }

        .screen.fixed-layout .btn-group {
            flex-shrink: 0;
            margin-top: 0;
            padding: 20px;
            background: var(--bg-color);
            border-top: 1px solid rgba(0,0,0,0.05); /* Optional: explicit separation */
        }

        /* Buttons */
        .btn-group {
            display: flex;
            flex-direction: column;
            gap: 16px;
            width: 100%;
            align-items: center;
            margin-top: 20px;
            margin-bottom: 20px;
        }

        .btn-group.bottom-push {
            margin-top: auto;
            margin-bottom: 20px;
        }

        button {
            border: none;
            border-radius: var(--radius);
            padding: 16px 32px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.1s, opacity 0.2s;
            width: auto; /* Not full width */
            min-width: 200px; /* Minimum reasonable width */
            height: 60px; /* Explicit height for consistency */
            max-width: 100%;
            touch-action: manipulation; /* Eliminate click delay */
        }

        button:active {
            transform: scale(0.96);
        }

        button.primary { background: var(--primary-color); color: white; }
        button.secondary { background: var(--secondary-color); color: white; }
        button.accent { background: var(--accent-color); color: black; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Inputs */
        input[type="text"], textarea {
            background: #e9edf5; /* Light gray to match the theme */
            border: 2px solid #d1d9e6;
            border-radius: var(--radius);
            padding: 16px;
            color: var(--text-color);
            font-size: 16px; /* iOS: Prevent auto-zoom on focus (must be >= 16px) */
            width: 100%;
            outline: none;
            transition: border-color 0.3s, box-shadow 0.3s;
            -webkit-appearance: none; /* Modern look on older iOS */
            appearance: none;
        }

        input[type="text"]:focus, textarea:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.2);
        }

        textarea { height: 120px; resize: none; font-size: 1.4rem; text-align: center; font-weight: bold; }

        .number-control {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 30px;
            margin: 20px 0;
        }

        .number-control button {
            width: 60px;
            min-width: 0;
            height: 60px;
            border-radius: var(--radius);
            font-size: 1.5rem;
            padding: 0;
        }

        .number-value {
            font-size: 3rem;
            font-weight: 800;
            min-width: 60px;
            text-align: center;
        }

        /* Player List */
        .player-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding-bottom: 20px;
        }

        .player-item {
            display: flex;
            gap: 10px;
            align-items: center;
            background: var(--card-bg);
            padding: 8px 4px 8px 16px; /* Reduced right padding to move 'x' button right */
            border-radius: var(--radius);
        }

        .player-item input {
            background: transparent;
            border: none;
            flex: 1;
            padding: 10px 0;
        }

        .btn-clear {
            background: transparent;
            color: var(--text-muted);
            font-size: 1.5rem;
            width: 32px; /* Slightly narrower to save space */
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* 戻るボタン（左上固定） */
        .btn-back {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 44px;
            height: 44px;
            min-width: 0;
            padding: 0;
            background: transparent;
            border: none;
            color: var(--text-color);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 100;
        }
        .btn-back svg {
            width: 24px;
            height: 24px;
            fill: currentColor;
        }

        /* Card Visual */
        .card-view {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .big-number, .reveal-number {
            font-size: 8rem;
            font-weight: 950;
            color: #ffffff;
            /* 太い縁取り (ユーザー提供画像に近いスタイル) */
            text-shadow:
                -4px -4px 0 #2b215a,
                 4px -4px 0 #2b215a,
                -4px  4px 0 #2b215a,
                 4px  4px 0 #2b215a,
                 0 0 20px rgba(0,0,0,0.5);
            margin: 20px 0;
            line-height: 1;
        }

        .reveal-number {
            font-size: 10rem;
        }

        /* Timer */
        .timer-val {
            font-size: 6rem;
            font-weight: 900;
            color: var(--accent-color);
            text-align: center;
            margin: 40px 0;
            font-variant-numeric: tabular-nums;
        }

        .timer-controls {
            display: flex;
            gap: 12px;
        }

        /* Drag Sort (Full screen scroll supported by parent) */
        .sortable-list {
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
            position: relative;
            /* touch-action: none; を削除：ブラウザや環境によってドラッグ開始を阻害する場合があるため */
        }

        /* SortableJS Styles & iPhone Effects */
        /* 並び替え中のスタイル（スライド方式） */
        .sortable-drag {
            opacity: 1.0 !important;
            z-index: 10000 !important;
            cursor: grabbing;
        }

        .sortable-ghost {
            opacity: 0.4 !important; /* 移動先の隙間は薄く表示 */
            box-shadow: none !important;
            transform: none !important;
        }

        .sortable-chosen {
            opacity: 1.0 !important;
        }

        .sortable-chosen {
            opacity: 1.0 !important; /* リスト内のカードは常に実体を表示 */
        }

        /* ぷるぷる揺れるアニメーション (iPhone風) */
        .shaking:not(.sortable-drag):not(.sortable-ghost) {
            animation: shaking 0.3s infinite;
        }

        @keyframes shaking {
            0% { transform: rotate(0.5deg); }
            25% { transform: rotate(-0.5deg); }
            50% { transform: rotate(0.4deg); }
            75% { transform: rotate(-0.4deg); }
            100% { transform: rotate(0.5deg); }
        }

        /* Unified Game Card Design */
        .game-card {
            background: #ffffff;
            color: #333333;
            border-radius: 16px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            border: 1px solid #eee;
            position: relative;
            overflow: hidden;
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
        }

        .sort-card {
            padding: 24px;
            margin-bottom: 12px;
            min-height: 80px;
            cursor: grab;
            width: 100%;
        }

        /* Repeated styles for .sort-card since 'composes' isn't standard CSS */
        .sort-card, .card-front, .card-back {
            background: #ffffff;
            color: #333333;
            border-radius: 16px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            border: 1px solid #eee;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
        }

        .sort-label {
            width: 100%;
            padding: 8px;
            text-align: center;
            font-weight: 900;
            color: var(--primary-color);
            font-size: 1.2rem;
            opacity: 0.8;
            margin: 10px 0;
            user-select: none;
        }

        .sort-card span {
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-family: inherit;
        }

        .floating-card span {
            font-size: 1.5rem;
            font-weight: 700;
        }

        .sort-card.dragging {
            display: none; /* Hide the actual element while dragging placeholder is handled in JS */
        }

        /* 3D Card Flip Animation */
        .reveal-container {
            width: 100%;
            display: flex;
            flex-direction: column-reverse; /* Smallest at bottom, largest at top */
            align-items: center;
            gap: 24px;
            padding: 20px 0;
            perspective: 1000px; /* Enable 3D */
        }

        .reveal-card {
            width: 100%;
            max-width: 400px;
            height: 100px;
            background: transparent;
            cursor: pointer;
            perspective: 1000px;
            display: block; /* Always visible in the list flow */
        }

        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            transform-style: preserve-3d;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border-radius: 20px;
        }

        .reveal-card.flipped .card-inner {
            transform: rotateY(180deg);
        }

        .card-front, .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            border-radius: 20px;
            box-sizing: border-box;
            /* 外枠（白） */
            background: #ffffff;
            border: 4px solid #ffffff;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px; /* 内側の色部分との隙間 */
        }

        .card-inner-color {
            width: 100%;
            height: 100%;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        /* エラー時：枠をグレーにする */
        .was-smaller .card-front, .was-smaller .card-back {
            background: #d1d9e6 !important;
            border-color: #abb2bf !important;
        }
        .was-smaller .r-name {
            color: #5c6370 !important;
        }
        /* 数字の色は白のまま維持する */
        .was-smaller .big-number {
            color: white !important;
        }

        .card-front {
            z-index: 2;
        }

        .card-back {
            transform: rotateY(180deg);
            z-index: 1;
        }

        .r-name { font-size: 1.2rem; font-weight: bold; opacity: 0.8; }
        .r-num-big { font-size: 7rem; font-weight: 900; line-height: 1; margin-top: 10px; }

        .reveal-card.current .card-inner {
            outline: 4px solid var(--accent-color);
            outline-offset: 8px;
            transform: scale(1.05);
        }

        /* Player color dots/borders */
        .color-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }

        .reveal-card .r-name { color: var(--text-muted); font-size: 1.2rem; }
        .reveal-card .r-num {
            font-size: 4rem;
            font-weight: 900;
            color: var(--accent-color);
            transition: all 0.3s ease;
        }

        .reveal-label {
            font-weight: 900;
            color: var(--primary-color);
            padding: 10px;
            font-size: 1.2rem;
            opacity: 0.8;
        }

        .game-status {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 9999;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 4rem;
            font-weight: 900;
            text-align: center;
            backdrop-filter: blur(10px);
            cursor: pointer;
        }

        .game-status::after {
            content: 'タップで閉じる';
            font-size: 1.2rem;
            color: var(--text-muted);
            margin-top: 20px;
            font-weight: normal;
        }

        .status-clear { color: var(--success-color); }
        .status-error { color: var(--error-color); }

        /* Helpers */
        .centered { text-align: center; }
        .mt-20 { margin-top: 20px; }
        .mb-10 { margin-bottom: 10px; }

        @keyframes popIn {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* 正解アニメ（軽量版） */
        @keyframes successPop {
        0% {
            transform: scale(1);
            box-shadow: 0 0 0 rgba(46, 204, 113, 0);
        }
        50% {
            transform: scale(1.05);
            box-shadow: 0 0 14px rgba(46, 204, 113, 0.5);
        }
        100% {
            transform: scale(1);
            box-shadow: 0 0 0 rgba(46, 204, 113, 0);
        }
        }

        .anim-success {
        animation: successPop 0.4s ease-out;
        will-change: transform;
        z-index: 10;
        }


        /* 失敗：一瞬赤くなる + 軽く横に揺れる (0.4s) */
        @keyframes failureShake {
            0% { transform: translateX(0); background-color: #ff4d4f; }
            20% { transform: translateX(-6px); }
            40% { transform: translateX(6px); }
            60% { transform: translateX(-6px); }
            80% { transform: translateX(6px); }
            100% { transform: translateX(0); background-color: inherit; } /* inherit or specific color? inner-color has bg set via inline style usually. */
        }
        /* inner-color自体にbackgroundがついているので、!importantで上書きするか、borderで表現するか。
           ユーザーは「一瞬赤くなる」と言っている。
           background-colorをアニメーションさせる場合、元の色はinline styleで指定されているため !important が必要かも。
           ただし keyframes 内で !important は使えないことが多い（ブラウザ依存）。
           なので、 ::after 疑似要素で赤いオーバーレイをかける手法が無難だが、
           今回はシンプルに filter を使うか、box-shadowで代用するか。
           いや、カードの背景を変えたい。
        */
        .anim-failure {
            animation: failureShake 0.4s ease-in-out forwards;
        }
        /* キーフレーム内で背景色変更を効かせるため、詳細度を高めるか、JSで制御するが、
           一旦 box-shadow (赤) の内側拡散(inset) で「赤くなる」を表現してみる。
           背景色保持のため。
        */
        @keyframes failureFlash {
            0% { transform: translateX(0); box-shadow: inset 0 0 0 100px #ff4d4f; }
            20% { transform: translateX(-5px); }
            40% { transform: translateX(5px); }
            60% { transform: translateX(-5px); box-shadow: inset 0 0 0 0 #ff4d4f; }
            80% { transform: translateX(5px); }
            100% { transform: translateX(0); }
        }
        /* Override specifically for failure flash */
        .anim-flash-failure {
            animation: animFlashFailure 0.5s ease-in-out forwards;
        }

        /* Setup Screen Styling */
        .setup-card {
            background: #f6f8fb;
            border-radius: 16px;
            padding: 24px 20px;
            margin-bottom: 24px;
            /* box-shadow: 0 4px 12px rgba(0,0,0,0.05); */
            /* border: 1px solid rgba(0,0,0,0.05); */
        }
        .setup-label {
            font-size: 1.1rem;
            font-weight: 800;
            color: var(--text-color);
            margin-bottom: 15px;
            display: block;
            text-align: center;
        }
        .custom-select {
            width: 100%;
            padding: 14px;
            font-size: 1rem;
            border-radius: 12px;
            border: 2px solid #e0e0e0;
            background-color: #f9f9f9;
            color: var(--text-color);
            font-weight: bold;
            outline: none;
            transition: border-color 0.3s;
        }
        .custom-select:focus {
            border-color: var(--secondary-color);
        }
        .btn-gacha {
        background: linear-gradient(135deg,#4a7dff,#7aa6ff);
        color: white;
        border: none;
        border-radius: 14px;
        padding: 0 20px;
        font-weight: 900;
        font-size: 1rem;

        display: flex;
        align-items: center;
        justify-content: center;
        white-space: nowrap;

        box-shadow:
            0 4px 10px rgba(255, 94, 98, 0.35),
            inset 0 -3px 0 rgba(0,0,0,0.15); /* 押せる感 */

        transition: transform 0.08s ease, filter 0.15s ease, box-shadow 0.15s ease;
    }

        /* 押した時 */
        .btn-gacha:active {
            transform: scale(0.95);
            filter: brightness(0.95);
            box-shadow:
                0 2px 5px rgba(255, 94, 98, 0.25),
                inset 0 2px 4px rgba(0,0,0,0.25);
        }

        .btn-gacha svg {
            width: 20px;
            height: 20px;
            margin-right: 6px;
            fill: currentColor;
        }

        /* Make topic input larger */
        #topic-input {
            margin-top: 4px; /* More compact */
            font-size: 1.4rem; /* Larger text */
            font-weight: bold;
            padding: 8px 12px;
            min-height: 50px; /* Smaller height (approx 1 line + padding) */
            line-height: 1.3;
            border: 2px solid #e0e0e0;
            resize: none;
        }
        #topic-input:focus {
            border-color: var(--primary-color);
        }
        /* Segmented Control */
        .segmented-control {
            display: flex;
            background: #e0e0e0;
            border-radius: 12px;
            padding: 4px;
            margin-bottom: 10px; /* Reduced from 20px */
        }
        .segmented-option {
            flex: 1;
            text-align: center;
            padding: 8px 4px;
            font-size: 0.9rem;
            font-weight: bold;
            color: #666;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.2s;
            user-select: none;
        }
        .segmented-option.active {
            background: #fff;
            color: var(--primary-color);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* Tab Content Types */
        .tab-content {
            display: none;
            animation: fadeIn 0.3s;
            /* Prevent height jump */
            min-height: 140px; /* Reduced from 250px */
        }
        .tab-content.active {
            display: flex;
            flex-direction: column;
            justify-content: flex-start; /* Align to top */
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .mode-description {
            font-size: 0.9rem;
            color: var(--text-muted);
            margin-bottom: 10px; /* Reduced from 15px */
            text-align: center;
            line-height: 1.4;
        }
        .mode-title {
            font-weight: 800;
            color: var(--text-color);
            display: block;
            margin-bottom: 4px;
        }

        /* List Mode Styling */
        .topic-list-group {
            margin-bottom: 15px;
        }
        .topic-list-header {
            font-weight: bold;
            color: var(--text-muted);
            font-size: 0.9rem;
            margin-bottom: 5px;
            border-bottom: 1px solid #eee;
            padding-bottom: 2px;
        }
        .topic-list-item {
            padding: 10px;
            border-bottom: 1px solid #f0f0f0;
            font-size: 0.95rem;
            cursor: pointer;
        }
        .topic-list-item:active {
            background-color: #f5f5f5;
        }
        /* Modal Overlay */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
            display: flex; /* Always flex, hide with visibility */
            justify-content: center;
            align-items: flex-end;
            backdrop-filter: blur(4px);

            /* Hidden State */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal-overlay.active {
            /* Visible State */
            opacity: 1;
            visibility: visible;
        }
        .modal-card {
            width: 100%;
            height: 90%; /* Almost full screen */
            background: #fff;
            border-radius: 20px 20px 0 0;
            box-shadow: 0 -4px 20px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;

            /* Hidden State (Slide down) */
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
        }
        .modal-overlay.active .modal-card {
            /* Visible State (Slide up) */
            transform: translateY(0);
        }
        .modal-header {
            padding: 15px 20px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-title {
            font-size: 1.2rem;
            font-weight: bold;
        }
        .modal-close {
            background: #eee;
            border: none;
            font-size: 0.9rem;
            font-weight: bold;
            color: #333;
            cursor: pointer;
            padding: 8px 16px;
            border-radius: 8px; /* Standard rounded rect */
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        .modal-close:active {
            background: #ddd;
        }
        .modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            -webkit-overflow-scrolling: touch;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- 画面1：タイトル画面 -->
        <section id="screen-title" class="screen centered active">
            <h1 class="title-large">ito</h1>
            <div class="btn-group">
                <button class="primary" onclick="app.navTo('players')">始める</button>
                <button class="secondary" onclick="app.navTo('howto')">あそびかた</button>
            </div>
        </section>

        <!-- 遊び方画面（仕様外だが遷移先として簡易実装） -->
        <section id="screen-howto" class="screen">
            <h2 class="screen-title">あそびかた</h2>
            <div style="flex:1; overflow-y:auto; padding:10px;">
                <p>①. 1〜100の数字が各プレイヤーに1枚配られます。</p><br>
                <p>②. お題に沿って、自分の数字を言葉で表現します。</p><br>
                <p>③. 全員で話し合い、数字が小さいと思う順に並べます。</p><br>
                <p>④. 順番に数字を公開し、すべて小さい順ならクリア！</p>
            </div>
            <button class="secondary" onclick="app.navTo('title')">戻る</button>
        </section>

        <!-- 画面2：プレイヤー設定 -->
        <!-- 画面2：プレイヤー設定 -->
        <section id="screen-players" class="screen fixed-layout">
            <button class="btn-back" onclick="app.navTo('title')">
                <svg viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
            </button>
            <div class="screen-header">
                <h2 class="screen-title">プレイヤー設定</h2>
                <div class="number-control">
                    <button class="secondary" onclick="app.updatePlayerCount(-1)">◀</button>
                    <div id="player-count-val" class="number-value">3</div>
                    <button class="secondary" onclick="app.updatePlayerCount(1)">▶</button>
                </div>
            </div>

            <div id="screen-players-content" class="screen-content">
                <div id="player-list" class="player-list">
                    <!-- JSで動的生成 -->
                </div>
            </div>

            <div class="btn-group">
                <button class="primary" onclick="app.navTo('game-setup')">ゲーム設定へ</button>
            </div>
        </section>

        <!-- 画面3：ゲーム設定 -->
        <section id="screen-game-setup" class="screen" style="padding-top: 50px;"> <!-- Add padding for back button -->
            <button class="btn-back" onclick="app.navTo('players')">
                <svg viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
            </button>
            <h2 class="screen-title" style="margin-bottom: 20px;">ゲーム設定</h2>

            <div class="screen-content" style="padding: 0 20px;">
                <!-- お題設定 -->
                <div class="setup-card">
                    <label class="setup-label">お題を決めよう！</label>

                    <!-- Segmented Control -->
                    <div class="segmented-control">
                        <div class="segmented-option active" onclick="app.switchTab('input')">入力</div>
                        <div class="segmented-option" onclick="app.switchTab('random')">ランダム</div>
                        <div class="segmented-option" onclick="app.switchTab('category')">カテゴリ</div>
                        <div class="segmented-option" onclick="app.switchTab('list')">一覧</div>
                    </div>

                    <!-- 1. Input Mode -->
                    <div id="tab-input" class="tab-content active">
                        <p class="mode-description">
                            <span class="mode-title"> 自分でお題を自由に決める</span>
                            好きなお題を入力して遊べます。<br>
                        </p>
                    </div>

                    <!-- 2. Random Mode -->
                    <div id="tab-random" class="tab-content">
                        <p class="mode-description">
                            <span class="mode-title"> 全お題から自動で1つ選ぶ</span>
                            <!-- 迷ったらこれ。<br>すぐ遊びたいとき用の完全おまかせ。 -->
                        </p>
                        <button class="btn-gacha" onclick="app.spinTopicGacha('all')" style="width:100%; height:50px;">
                            <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-5.5-2.5l7.51-3.22-7.52-1.5z"/></svg>
                            ランダム
                        </button>
                    </div>

                    <!-- 3. Category Mode -->
                    <div id="tab-category" class="tab-content">
                        <p class="mode-description">
                            <span class="mode-title"> ジャンルを選んでランダム</span>
                            <!-- 食べ物・キャラ・感情など、<br>好きなジャンルだけで遊べます。 -->
                        </p>
                        <div style="display:flex; gap:10px; flex-direction:column;">
                            <select id="topic-category" class="custom-select">
                                <!-- JS Populated -->
                            </select>
                            <button class="btn-gacha" onclick="app.spinTopicGacha('category')" style="width:100%; height:50px;">
                                <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-5.5-2.5l7.51-3.22-7.52-1.5z"/></svg>
                                このジャンルでランダム
                            </button>
                        </div>
                    </div>

                    <!-- 4. List Mode -->
                    <div id="tab-list" class="tab-content">
                         <p class="mode-description">
                            <span class="mode-title"> お題を一覧から選ぶ</span>
                        </p>
                        <div style="display: flex; align-items: center; justify-content: center; height: 100%;">
                             <button class="secondary" onclick="app.showTopicListModal()" style="padding: 10px 20px;">
                                お題一覧を開く
                             </button>
                        </div>
                    </div>

                    <textarea id="topic-input" placeholder="ここに&#10;お題が表示されます" style="margin-top:15px; min-height:80px;"></textarea>

                </div>

                <!-- タイマー設定 -->
                <div class="setup-card">
                    <label class="setup-label">トーク時間</label>
                    <div class="number-control" style="justify-content: center;">
                        <button class="secondary" style="width:60px; height:60px; font-size:1.5rem;" onclick="app.updateTimerSetting(-1)">◀</button>
                        <div id="timer-setting-val" class="number-value" style="font-size:3rem; width:100px;">3</div>
                        <button class="secondary" style="width:60px; height:60px; font-size:1.5rem;" onclick="app.updateTimerSetting(1)">▶</button>
                    </div>
                    <p style="text-align:center; color:var(--text-muted); font-weight:bold; margin-top:5px;">分</p>
                </div>
            </div>

            <div class="btn-group">
                <button class="primary" onclick="app.startGame()">設定OK！始める</button>
            </div>
        </section>

        <!-- 画面4：数字確認案内 -->
        <section id="screen-dist-info" class="screen centered dist-screen">
            <h2 id="dist-player-name" class="screen-title">プレイヤーXさん</h2>
            <div style="height: 350px; display: flex; align-items: center; justify-content: center; text-align: center;">
                <p style="font-size: 1.5rem; font-weight: bold; line-height: 1.4;">数字を表示します。<br><span style="font-size: 1rem; font-weight: normal; color: var(--text-muted);">他のプレイヤーに見られないようにしてください。</span></p>
            </div>
            <div class="btn-group bottom-push">
                <button class="primary" onclick="app.navTo('dist-reveal')">表示</button>
            </div>
        </section>

        <!-- 画面5：数字表示 -->
        <section id="screen-dist-reveal" class="screen centered dist-screen">
            <h2 id="reveal-player-name" class="screen-title">プレイヤーXさん</h2>
            <div id="dist-number-view" class="card-view" style="width: 100%; height: 350px; display: flex; align-items: center; justify-content: center;">
                <!-- JSで直接数字を表示 -->
            </div>
            <div class="btn-group bottom-push">
                <button class="primary" onclick="app.nextDistReveal()">覚えた！</button>
            </div>
        </section>

        <!-- 画面7：ゲーム開始待機 -->
        <section id="screen-wait-start" class="screen centered dist-screen">
            <h2 class="screen-title">全員確認完了</h2>
            <div style="height: 350px; display: flex; align-items: center; justify-content: center; text-align: center;">
                <p style="font-size: 1.5rem; font-weight: bold;">準備ができたら開始してください</p>
            </div>
            <div class="btn-group bottom-push">
                <button class="primary" onclick="app.startThinking()">ゲーム開始</button>
            </div>
        </section>

        <!-- 画面8：トーク & 並び替え (統合画面) -->
        <section id="screen-game-play" class="screen fixed-layout">
            <div class="screen-header" style="padding-bottom: 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.05);">
                <div class="topic-header" style="width:100%; background:var(--accent-color); padding:10px 15px; border-radius:12px; margin-bottom:8px; display:flex; align-items:center; justify-content:center;">
                    <p id="timer-topic" style="color:var(--text-color); font-size:1.1rem; font-weight:800; text-align:center; margin:0;"></p>
                </div>

                <div style="display: flex; align-items: center; justify-content: center; gap: 15px; width: 100%;">
                    <div id="timer-display" class="timer-val" style="margin: 0; font-size: 2.2rem; color: var(--text-color);">03:00</div>
                    <div class="timer-controls" style="gap:8px;">
                        <button class="secondary" style="width:50px; height:40px; padding:0; min-width:50px; font-size:0.9rem;" onclick="app.adjustTimer(-60)">-1分</button>
                        <button class="secondary" style="width:50px; height:40px; padding:0; min-width:50px; font-size:0.9rem;" onclick="app.adjustTimer(60)">+1分</button>
                    </div>
                </div>
                <div style="width: 100%; text-align: center; margin-top: 5px;">
                     <p class="centered" style="font-size:0.9rem; font-weight:bold; color:var(--text-muted); margin:0;">↓ 小さい順に並び替え ↓</p>
                </div>
            </div>

            <div class="screen-content" style="padding-top: 10px;">
                <div id="sortable-list" class="sortable-list">
                    <!-- JSで並び替えUI -->
                </div>
            </div>

            <div class="btn-group" style="padding: 10px 20px 20px 20px; background: var(--bg-color); border-top: 1px solid rgba(0,0,0,0.05);">
                <button class="primary" onclick="app.finishGamePlay()">決定</button>
            </div>
        </section>

        <!-- 画面10：結果発表 -->
        <section id="screen-result" class="screen fixed-layout" onclick="app.handleResultClick(event)">
            <div id="game-status" class="game-status"></div>

            <div class="screen-header" style="padding-bottom:10px; box-shadow:0 4px 10px rgba(0,0,0,0.05);">
                <h2 class="screen-title" style="margin-bottom:10px;">結果発表</h2>
            </div>

            <div class="screen-content" style="padding:10px 20px;">
                <div class="reveal-label" style="padding:5px; text-align:center;">▲ 大きい</div>
                <div id="reveal-container" class="reveal-container" style="padding:0;">
                    <!-- タップで次をめくる -->
                </div>
                <div class="reveal-label" style="padding:5px; text-align:center;">▼ 小さい</div>
            </div>

            <div class="btn-group" style="padding:10px 20px 20px 20px; background:var(--bg-color); border-top:1px solid rgba(0,0,0,0.05); gap:10px;">
                <div id="result-btns" style="display:none; flex-direction:column; gap:16px; width:100%; align-items:center;">
                    <button class="primary" onclick="app.startGame()">次のゲームへ</button>
                    <button class="secondary" onclick="app.navTo('players')">設定へ</button>
                </div>
            </div>
        </section>

        <!-- Topic List Modal -->
        <div id="topic-modal" class="modal-overlay" onclick="app.closeTopicListModal(event)">
            <div class="modal-card" onclick="event.stopPropagation()">
                <div class="modal-header">
                    <div class="modal-title">お題一覧</div>
                    <button class="modal-close" onclick="app.closeTopicListModal()">閉じる</button>
                </div>
                <div id="modal-topic-list" class="modal-body">
                    <!-- JS Populated -->
                </div>
            </div>
        </div>
    </div>

    <!-- External Data -->
    <script src="main.js"></script>

    <script>
        /**
         * アプリ全体のロジック管理オブジェクト
         */
        const app = {
            // アプリケーションの状態（データ）
            state: {
                currentScreen: 'title', // 現在表示中の画面ID
                playerCount: 3,         // 参加人数
                players: [],            // プレイヤー情報（名前、数字、色）の配列
                playerColors: [         // プレイヤーにランダムに割り振るカラーパレット
                    '#ff5252', '#4caf50', '#2196f3', '#ffeb3b', '#ff9800', '#9c27b0', '#00bcd4', '#e91e63'
                ],
                timerSetting: 3,        // 設定されたトーク時間（分）
                topic: '',              // 現在のお題
                distIndex: 0,           // 配布フェーズの現在のプレイヤー番号
                revealIndex: 0,         // 結果発表フェーズの現在のカード番号
                isGameOver: false,      // ゲーム終了フラグ
                hasError: false,        // 数字の順序ミスが発生したかの記録
                timerId: null,          // タイマーのインターバルID
                timeLeft: 0,            // 残り時間（秒）
                sortingOrder: [],       // プレイヤーが並び替えた後のインデックス順序
                currentScreen: 'title'  // 現在の画面ID
            },

            /**
             * アプリの初回起動処理
             */
            init() {
                this.loadState();        // 保存されたデータの読み込み
                this.populateCategories(); // カテゴリーの初期化
                this.populateTopicList(); // 一覧の初期化

                // 復帰処理
                if (this.state.currentScreen) {
                    this.navTo(this.state.currentScreen);

                    // ゲームプレイ中の場合、タイマーと並び替えを再開
                    if (this.state.currentScreen === 'game-play') {
                        this.startTimerLoop();
                        this.initSorting();
                    }
                } else {
                    this.navTo('title');     // 初期画面（タイトル）を表示
                }

                this.renderPlayerInputs();
                this.registerSW();       // PWA用サービスワーカーの登録

                // 結果発表オーバーレイをクリックで閉じられるように
                document.getElementById('game-status').onclick = () => {
                    document.getElementById('game-status').style.display = 'none';
                };

                // 初期タブを設定
                this.switchTab('input');
            },

            /**
             * 画面遷移を処理する
             * @param {string} screenId 遷移先の画面ID
             */
            navTo(screenId) {
                // 全ての画面を非表示にして、対象の画面だけ表示
                document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
                const target = document.getElementById('screen-' + screenId);
                if (target) {
                    target.classList.add('active');
                    this.state.currentScreen = screenId;
                    this.saveState(); // 画面遷移ごとに保存
                }
                window.scrollTo(0, 0);

                // 画面遷移時に一度だけ必要な初期化処理
                if (screenId === 'dist-info') this.updateDistInfo();
                if (screenId === 'dist-reveal') this.updateDistView();
                if (screenId === 'result') this.initResult();
            },

            /**
             * プレイヤー人数の変更
             * @param {number} v 増加分(+1) または 減少分(-1)
             */
            updatePlayerCount(v) {
                const newCount = this.state.playerCount + v;
                if (newCount >= 2 && newCount <= 10) {
                    this.state.playerCount = newCount;
                    document.getElementById('player-count-val').innerText = newCount;
                    this.renderPlayerInputs(); // 入力欄を再生成
                    this.saveState();
                }
            },

            /**
             * プレイヤー名入力欄の動的生成
             */
            renderPlayerInputs() {
                const list = document.getElementById('player-list');
                // 現在の入力を一時保存（人数を変えても名前が消えないように）
                const currentInputs = Array.from(list.querySelectorAll('input')).map(i => i.value);
                list.innerHTML = '';

                for (let i = 0; i < this.state.playerCount; i++) {
                    const color = this.state.playerColors[i % this.state.playerColors.length];
                    const row = document.createElement('div');
                    row.className = 'player-item';
                    const name = currentInputs[i] || this.state.players[i]?.name || '';
                    row.innerHTML = `
                        <div class="color-dot" style="background: ${color}"></div>
                        <input type="text" placeholder="プレイヤー${i+1}" value="${name}">
                        <button class="btn-clear" onclick="this.previousElementSibling.value=''">×</button>
                    `;
                    list.appendChild(row);
                }
            },

            // --- ゲーム設定 & 開始 ---
            updateTimerSetting(v) {
                const newVal = this.state.timerSetting + v;
                if (newVal >= 1 && newVal <= 30) {
                    this.state.timerSetting = newVal;
                    document.getElementById('timer-setting-val').innerText = newVal;
                    this.saveState();
                }
            },

            /**
             * ゲーム開始：数字の配布とお題の設定を行う
             */
            startGame() {
                // プレイヤー情報の確定
                const inputs = document.querySelectorAll('#player-list input');
                this.state.players = Array.from(inputs).map((input, i) => ({
                    name: input.value || `プレイヤー${i+1}`,
                    number: 0,
                    color: this.state.playerColors[i % this.state.playerColors.length]
                }));

                // お題の保存
                this.state.topic = document.getElementById('topic-input').value;

                // 1-100の数字をシャッフルして配布（重複なし）
                const nums = Array.from({length: 100}, (_, i) => i + 1);
                for (let i = nums.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [nums[i], nums[j]] = [nums[j], nums[i]];
                }
                this.state.players.forEach((p, i) => p.number = nums[i]);

                this.state.distIndex = 0;
                this.saveState();
                this.navTo('dist-info'); // 配布案内画面へ
            },

            // --- 配布フロー ---
            updateDistInfo() {
                const p = this.state.players[this.state.distIndex];
                document.getElementById('dist-player-name').innerText = p.name + ' さん';
            },

            updateDistView() {
                const p = this.state.players[this.state.distIndex];
                if (!p) return;

                const revealName = document.getElementById('reveal-player-name');
                if (revealName) revealName.innerText = p.name + ' さん';

                const view = document.getElementById('dist-number-view');
                if (view) {
                    view.innerHTML = `
                        <div class="card-front" style="position: relative; width: 260px; height: 260px; border: 6px solid ${p.color};">
                            <div class="card-inner-color" style="background: ${p.color}">
                                <div style="color: rgba(255,255,255,0.8); font-size: 1rem; margin-bottom: 5px; font-weight: 900;">YOUR NUMBER</div>
                                <div class="big-number" style="margin: 0; font-size: 8rem;">${p.number}</div>
                            </div>
                        </div>
                    `;
                }
            },
            nextDistReveal() {
                if (this.state.distIndex < this.state.playerCount - 1) {
                    this.state.distIndex++;
                    this.navTo('dist-info');
                } else {
                    this.navTo('wait-start');
                }
                this.saveState();
            },

            // --- トーク & 並び替え (統合ロジック) ---
            startThinking() {
                this.navTo('game-play');
                this.state.timeLeft = this.state.timerSetting * 60;
                document.getElementById('timer-topic').innerText = `お題：${this.state.topic}`;
                this.updateTimerUI();
                this.initSorting();
                this.startTimerLoop();
            },

            startTimerLoop() {
                // タイマー表示の復元
                document.getElementById('timer-topic').innerText = `お題：${this.state.topic}`;
                this.updateTimerUI();

                if (this.state.timerId) clearInterval(this.state.timerId);
                this.state.timerId = setInterval(() => {
                    if (this.state.timeLeft > 0) {
                        this.state.timeLeft--;
                        this.updateTimerUI();
                        // 10秒ごとに自動保存（念のため）
                        if (this.state.timeLeft % 10 === 0) this.saveState();
                    } else {
                        clearInterval(this.state.timerId);
                    }
                }, 1000);
            },

            adjustTimer(v) {
                this.state.timeLeft = Math.max(0, this.state.timeLeft + v);
                this.updateTimerUI();
            },

            updateTimerUI() {
                const m = Math.floor(this.state.timeLeft / 60);
                const s = this.state.timeLeft % 60;
                document.getElementById('timer-display').innerText =
                    `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
            },

            finishGamePlay() {
                clearInterval(this.state.timerId);
                // 結果発表の初期化
                this.state.revealIndex = 0;
                this.state.isGameOver = false;
                this.state.hasError = false;
                this.saveState();
                this.navTo('result');
            },

            // --- 並び替え (SortableJS) ---
            initSorting() {
                const list = document.getElementById('sortable-list');

                // 既存のインスタンスがあれば破棄する
                if (this.sortableInstance) {
                    this.sortableInstance.destroy();
                    this.sortableInstance = null;
                }

                this.state.sortingOrder = this.state.players.map((_, i) => i);
                this.renderSortingCards();

                this.sortableInstance = new Sortable(list, {
                    animation: 200,           // 標準のアニメーション速度
                    easing: "cubic-bezier(0.25, 1, 0.5, 1)",
                    delay: 100,               // PC/マウスは即反応
                    delayOnTouchOnly: true,
                    touchStartThreshold: 3,   // 誤動作防止
                    forceFallback: false,     // ネイティブドラッグに戻して動作を安定化
                    fallbackOnBody: false,    // ボディに追加しない
                    draggable: '.sort-card',  // 対象要素
                    ghostClass: 'sortable-ghost',
                    dragClass: 'sortable-drag',
                    chosenClass: 'sortable-chosen',
                    onStart: (evt) => {
                        list.classList.add('is-dragging');
                        if (navigator.vibrate) navigator.vibrate(50);
                    },
                    onEnd: () => {
                        list.classList.remove('is-dragging');
                        // 全てのカードの透明度を確実にリセット
                        list.querySelectorAll('.sort-card').forEach(el => {
                            el.style.opacity = '';
                        });

                        // 状態を同期
                        const pIndexes = Array.from(list.querySelectorAll('.p-idx')).map(el => parseInt(el.value));
                        this.state.sortingOrder = pIndexes;
                        this.saveState();
                    }
                });
            },

            renderSortingCards() {
                const list = document.getElementById('sortable-list');
                list.innerHTML = '';

                // Label: Big (Top)
                const bigLabel = document.createElement('div');
                bigLabel.className = 'sort-label';
                bigLabel.innerText = '▲ 大きい';
                list.appendChild(bigLabel);

                this.state.sortingOrder.forEach((pIdx, i) => {
                    const p = this.state.players[pIdx];
                    const card = document.createElement('div');
                    card.className = 'sort-card';
                    // 結果発表のカードデザインを流用
                    card.style.border = `6px solid ${p.color}`;
                    card.style.padding = '24px';
                    card.style.marginBottom = '16px';
                    card.style.width = '100%';
                    card.style.maxWidth = '400px';
                    card.style.boxShadow = '0 10px 30px rgba(0,0,0,0.1)';
                    card.innerHTML = `
                        <input type="hidden" class="p-idx" value="${pIdx}">
                        <div style="font-weight: 950; font-size: 1.5rem; color: #000; line-height: 1;">${p.name}</div>
                    `;
                    list.appendChild(card);
                });

                // Label: Small (Bottom)
                const smallLabel = document.createElement('div');
                smallLabel.className = 'sort-label';
                smallLabel.innerText = '▼ 小さい';
                list.appendChild(smallLabel);
            },

            // (Sorting is handled by SortableJS now, manual drag logic removed)
            // --- 結果発表 ---
            initResult() {
                const container = document.getElementById('reveal-container');
                const status = document.getElementById('game-status');
                status.style.display = 'none';
                status.className = 'game-status';
                status.innerText = '';
                document.getElementById('result-btns').style.display = 'none';
                container.innerHTML = '';

                this.state.revealIndex = this.state.revealIndex || 0; // 既存の状態があれば維持、なければ0
                // this.state.isGameOver = false; // ここでリセットしない（finishGamePlayで行う）
                // this.state.hasError = false;   // 同上

                // Display from Small (Bottom) to Large (Top)
                // sortingOrder is [Large ... Small] (User input: Top to Bottom)
                // We want to append Small first (Bottom), so we need to reverse sortingOrder.
                const displayList = [...this.state.sortingOrder].reverse();

                displayList.forEach((pIdx, i) => {
                    const p = this.state.players[pIdx];
                    const card = document.createElement('div');
                    card.className = 'reveal-card';
                    card.dataset.pIdx = pIdx; // Store player index for easy retrieval
                    card.innerHTML = `
                        <div class="card-inner">
                            <div class="card-front" style="border: 6px solid ${p.color}; padding: 24px;">
                                <div class="r-name" style="font-weight: 950; font-size: 1.5rem; color: #000; line-height: 1;">${p.name}</div>
                                <div style="font-size: 0.6rem; margin-top: 4px; color: #999; font-weight: 800;">タップしてめくる</div>
                            </div>
                            <div class="card-back">
                                <div class="card-inner-color" style="background: ${p.color}">
                                    <div class="big-number" style="font-size: 4rem;">${p.number}</div>
                                </div>
                            </div>
                        </div>
                    `;
                    // 復元時：すでにめくられているカードはフリップ状態にする
                    if (i < this.state.revealIndex) {
                        card.classList.add('flipped');
                    }
                    // card.onclick = () => this.revealNext(i); // Removed individual click handler
                    container.appendChild(card);
                });

                setTimeout(() => {
                    const cards = document.querySelectorAll('.reveal-card');
                    // 次にめくるべきカードをハイライト
                    if (!this.state.isGameOver && cards[this.state.revealIndex]) {
                        cards[this.state.revealIndex].classList.add('current');
                        // 最初のカードが見えるようにスクロール
                        cards[this.state.revealIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 100);

                // ゲームオーバー状態なら結果を表示
                if (this.state.isGameOver) {
                    this.showGameOver(!this.state.hasError);
                }
            },

            // New method to handle clicks anywhere on the result screen
            handleResultClick(e) {
                // Ignore clicks on header or footer areas (only allow clicks in content)
                if (e.target.closest('.screen-header') || e.target.closest('.btn-group') || e.target.closest('button')) return;

                // Only trigger if game is not over
                if (!this.state.isGameOver) {
                    this.revealNext(this.state.revealIndex);
                }
            },

            revealNext(i) {
                if (this.state.isGameOver) return;
                if (i >= this.state.playerCount) return;

                if (i !== this.state.revealIndex) return;

                const cards = document.querySelectorAll('.reveal-card');
                const card = cards[i];
                if (card.classList.contains('flipped')) return;

                // カードをめくる処理（結果発表）
                card.classList.add('flipped');
                card.classList.remove('current'); // 強調解除

                // めくったカードを画面中央に持ってくる（すぐに見えるように）
                card.scrollIntoView({ behavior: 'smooth', block: 'center' });

                const pIdx = parseInt(card.dataset.pIdx);
                const num = this.state.players[pIdx].number;

                // Vibrate for feedback
                if (navigator.vibrate) navigator.vibrate([10, 30, 20]);

                const prevCard = (i > 0) ? cards[i-1] : null;
                let prevNum = -1;
                let prevWasError = false;

                if (prevCard) {
                    const prevPIdx = parseInt(prevCard.dataset.pIdx);
                    prevNum = this.state.players[prevPIdx].number;
                    prevWasError = prevCard.classList.contains('was-smaller');
                }

                // 判定ロジック：
                // revealOrder is Small -> Large.
                // So current num should be >= prevNum.
                // If num < prevNum, it's an error.
                let isError = false;
                if (prevCard && num < prevNum) {
                    this.state.hasError = true;
                    isError = true;
                    card.classList.add('was-smaller'); // ミスしたカードをグレーにする (CSSで制御)
                }

                // アニメーション適用（1枚目は何もしない＝prevCardがある場合のみ演出）
                if (prevCard) {
                    // フリップアニメーション(0.8s)と合わせるか、フリップ後にするか。
                    // ユーザー体験的には「めくった瞬間」にわかりたい。
                    // しかしDOM上はめくると同時にクラスが付与される。
                    // フリップ中（裏面が見え始めた頃）に光るとかっこいい。
                    const target = card.querySelector('.card-inner-color'); // 裏面の色領域

                    // アニメーションのリセット（再実行用）
                    target.classList.remove('anim-success', 'anim-failure');
                    void target.offsetWidth; // reflow

                    if (isError) {
                        // 失敗演出 (0.4s)
                        // フリップが0.8sなので、少し遅らせる？
                        // いや、すぐに発火でOK。裏面が見える頃に赤くなる。
                        // ただし、rotateY(180deg) されているので、translateXの方向が逆に見えるかもだが、shakeなら気にならない。
                        setTimeout(() => {
                           target.classList.add('anim-failure');
                        }, 200); // 少しだけ待つ
                    } else {
                        // 正解演出 (0.3s)
                        setTimeout(() => {
                            target.classList.add('anim-success');
                        }, 200);
                    }
                }

                this.state.revealIndex++;
                if (this.state.revealIndex === this.state.playerCount) {
                    this.state.isGameOver = true;
                    // 全てめくり終わったタイミングで、ミスがあったかどうかで結果を変える
                    setTimeout(() => {
                        this.showGameOver(!this.state.hasError);
                        this.saveState();
                    }, 1000);
                } else {
                    // 次のカードへスクロール（少し余裕を持たせる：1.5秒後）
                    setTimeout(() => {
                        const nextCard = cards[this.state.revealIndex];
                        nextCard.classList.add('current');
                        nextCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        this.saveState();
                    }, 1500);
                }
            },

            /**
             * ゲーム終了の判定とアニメーション
             * @param {boolean} isClear 数字が全て小さい順だったか
             */
            showGameOver(isClear) {
                const status = document.getElementById('game-status');
                status.innerText = isClear ? 'CLEAR!' : 'FAILED';
                status.classList.add(isClear ? 'status-clear' : 'status-error');
                status.style.display = 'flex'; // オーバーレイを表示

                // 次のゲームや設定へ進むためのボタンを表示
                document.getElementById('result-btns').style.display = 'flex';
            },

            // --- 状態保存 ---
            // --- 状態保存 ---
            saveState() {
                const s = { ...this.state };
                delete s.timerId; // タイマーIDは保存しない
                localStorage.setItem('ito_game_state', JSON.stringify(s));
            },
            loadState() {
                try {
                    const saved = localStorage.getItem('ito_game_state');
                    if (saved) {
                        const parsed = JSON.parse(saved);
                        // マージ（既存のデフォルト値を上書き）
                        this.state = { ...this.state, ...parsed };

                        // DOMへの反映
                        if (this.state.playerCount) {
                             document.getElementById('player-count-val').innerText = this.state.playerCount;
                        }
                        if (this.state.timerSetting) {
                             document.getElementById('timer-setting-val').innerText = this.state.timerSetting;
                        }
                        if (this.state.topic) {
                            document.getElementById('topic-input').value = this.state.topic;
                        }
                    }
                } catch (e) {
                    console.error('State load failed:', e);
                }
            },

            registerSW() {
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.register('./sw.js').catch(() => {});
                }
            },

            // --- Topic UI Logic ---
            switchTab(mode) {
                // Update buttons
                const options = document.querySelectorAll('.segmented-option');
                options.forEach(opt => opt.classList.remove('active'));

                // Find index based on mode order: input, random, category, list
                const map = { 'input': 0, 'random': 1, 'category': 2, 'list': 3 };
                if (options[map[mode]]) options[map[mode]].classList.add('active');

                // Update content
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                const content = document.getElementById('tab-' + mode);
                if (content) content.classList.add('active');

                // Mode specific actions
                if (mode === 'input') {
                    document.getElementById('topic-input').focus();
                }
            },


            // --- Modal Logic ---
            showTopicListModal() {
                const modal = document.getElementById('topic-modal');
                modal.classList.add('active'); // active for overlay
                // prevent body scroll
                document.body.style.overflow = 'hidden';
            },

            closeTopicListModal(e) {
                // If event provided, check if it is valid close
                if (e && e.target !== e.currentTarget) return;

                const modal = document.getElementById('topic-modal');
                modal.classList.remove('active');
                document.body.style.overflow = '';
            },

            populateCategories() {
                const select = document.getElementById('topic-category');
                if (!select || typeof categorizedTopics === 'undefined') return;

                select.innerHTML = ''; // Reset

                Object.keys(categorizedTopics).forEach(cat => {
                    const option = document.createElement('option');
                    option.value = cat;
                    option.innerText = cat;
                    select.appendChild(option);
                });
            },

            populateTopicList() {
                const container = document.getElementById('modal-topic-list'); // Changed target to modal
                if (!container || typeof categorizedTopics === 'undefined') return;

                container.innerHTML = '';

                Object.keys(categorizedTopics).forEach(cat => {
                    // Group Header
                    const header = document.createElement('div');
                    header.className = 'topic-list-header';
                    header.innerText = cat;
                    header.style.padding = "10px 10px 5px";
                    header.style.backgroundColor = "#fff";
                    header.style.position = "sticky"; // Might need adjustment in modal
                    header.style.top = "0";
                    header.style.zIndex = "10";
                    container.appendChild(header);

                    // Topics
                    categorizedTopics[cat].forEach(topic => {
                        const div = document.createElement('div');
                        div.className = 'topic-list-item';
                        div.innerText = topic;
                        div.onclick = () => {
                            // Close modal
                            this.closeTopicListModal();

                            // Use Input mode
                            this.switchTab('input');

                            const input = document.getElementById('topic-input');
                            input.value = topic;

                            // Flash effect
                            input.style.transition = 'none';
                            input.style.backgroundColor = 'var(--primary-color)';
                            input.style.color = '#fff';
                            setTimeout(() => {
                                input.style.transition = 'background-color 0.5s, color 0.5s';
                                input.style.backgroundColor = '#fff';
                                input.style.color = '#000';
                            }, 100);
                        };
                        container.appendChild(div);
                    });
                });
            },

            spinTopicGacha(mode = 'all') {
                if (typeof categorizedTopics === 'undefined') {
                    alert('お題データが読み込めませんでした');
                    return;
                }

                let candidates = [];
                // If mode is 'category', read from select. Else 'all'.
                // Reuse logic slightly.

                if (mode === 'all') {
                    Object.values(categorizedTopics).forEach(list => {
                        candidates = candidates.concat(list);
                    });
                } else if (mode === 'category') {
                    const category = document.getElementById('topic-category').value;
                    candidates = categorizedTopics[category] || [];
                }

                if (candidates.length === 0) {
                    alert('お題が見つかりませんでした');
                    return;
                }

                // ランダムに選出
                const randomTopic = candidates[Math.floor(Math.random() * candidates.length)];

                // 入力欄にセット & アニメーション
                const input = document.getElementById('topic-input');
                input.value = randomTopic;

                // 簡単な強調演出
                input.style.transition = 'none';
                input.style.backgroundColor = 'var(--primary-color)';
                input.style.color = '#fff';
                setTimeout(() => {
                    input.style.transition = 'background-color 0.5s, color 0.5s';
                    input.style.backgroundColor = '#fff';
                    input.style.color = '#000';
                }, 100);
            }
        };

        window.onload = () => app.init();
    </script>
</body>
</html>
